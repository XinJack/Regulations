(1)什么是Prolog
	Prolog是Programming in LOGic的缩写，意思就是使用逻辑的语言编写程序。它建立在逻辑学的理论基础之上， 最初被运用于自然语言等研究领域。现已广泛的应用在人工智能的研究中，可以用来建造专家系统、自然语言理解、智能知识库等。同时对一些通常的应用程序的编写也很有帮助，能够比其他的语言更快速地开发程序，因为它的编程方法更象是使用逻辑的语言来描述程序。
	Prolog语言最早由Aix-Marseille大学的Alain Colmerauer与Phillipe Roussel等人于60年代末研究开发。1972年被公认为是Prolog语言正式诞生的年份，自1972年以后，分支出多种Prolog的方言。1995年确定了ISOProlog标准。
	完整的prolog程序是由事实和规则组成的。事实用来储存一些数据，而规则用来储存某种可以推理出来的关系。
	prolog很适合于开发有关人工智能方面的程序，例如：专家系统、自然语言理解、定理证明以及许多智力游戏。
(2)Prolog的特点
	1. prolog程序没有特定的运行顺序，其运行顺序是由电脑决定的，而不是编程序的人。
		从这个意义上来说，prolog程序不是真正意义上的程序。所谓程序就是按照一定的步骤运行的计算机指令，而prolog程序的运行步骤不由人来决定。它更像一种描述型的语言，用特定的方法描述一个问题，然后由电脑自动找到这个问题的答案。举个极端的例子，你只需要把某个数学题目告诉它，它就会自动的找到答案，而不像使用其他的语言一样，必须人工的编制出某种算法。
	2. prolog程序中没有if、when、case、for这样的控制流程语句
		前面已经说了，程序的运行方式有电脑自己决定，当然就用不到这些控制流程的语句了。通常情况下，程序员不需要了解程序的运行过程，只需要注重程序的描述是否全面，不过prolog也提供了一些控制流程的方法，这些方法和其他语言中的方法有很大的区别，希望你在以后的学习当中能够融会贯通。
	3. prolog程序和数据高度统一
		在prolog程序中，是很难分清楚哪些是程序，哪些是数据的。事实上，prolog中的所有东西都有相同的形式，也就是说数据就是程序，程序就是数据。举一个其他语言的例子：如果想用c语言编写一个计算某个数学表达式的程序很简单(比如：a=2+5*4)，因为这是一段程序。但是如果想编写一个计算用户输入的表达式的值的程序就很困难了。因为用户输入的是一段数据(字符串)，如果想让c语言处理这个字符串，就需要很多方面的技术。则正是因为在c语言中，程序和数据是分开的。而在prolog就不存在这个问题，你甚至可以很轻松的编写处理其它prolog程序的程序。
	4. prolog程序实际上是一个智能数据库
		prolog的原理就是关系数据库，它是建立在关系数据库的基础上的。在以后的学习中你会发现它和SQL数据库查询语言有很多相似之处。使用prolog可以很方便的处理数据。
	5. 强大的递归功能
		在其它的语言中，你也许已经接触过递归程序了。递归是一种非常简洁的方式，它能够有效的解决许多难题。而在prolog中，递归的功能得到了充分的体现，你甚至都会感到惊奇，递归居然又如此巨大的能力
(3)事实谓词
	事实（facts）是prolog中最简单的谓词（predicate）。它和关系数据库中的记录十分相似。
	谓词：Prolog语言的基本组成元素，可以是一段程序、一个数据类型或者是一种关系。它由谓词名和参数组成。两个名称相同而参数的数目不同的谓词是不同的谓词。
	事实的语法结构为pred(arg1, arg2, ..., argN). 其中pred为谓词的名称，括号内为参数，'.'是所有Prolog子句的结束符。没有参数的谓词形式为pred.
	参数可以是以下四种之一：
		整数（integer) 绝对值小于某一个数的正数或负数。
		原子（atom） 由小写字母开头的字符串。原子通常是字母和数字组成，开头的字符必须是小写字母。使用单引号扩起来的字符集都是合法的原子。hello为合法原子，而hello world为非法原子但'hello world'又是合法原子。
		变量（variable） 由大写字母或下划线（_）开头。
		结构（structure） 在以后的章节介绍。
	Prolog的解释器提供了动态储存事实和规则的方法，并且也提供了访问它们的方法。数据库的更新是通过运consult或reconsult命令。我们也可以直接在解释器中输入谓词，但是这些谓词不会被储存到硬盘上。
(4)简单查询
	Prolog的查询工作是靠模式匹配完成的。查询的模板叫做目标(goal)。如果有某个事实与目标匹配，那么查询就成功了，Prolog的解释器会回显’yes.’。如果没有匹配的事实，查询就失败了，解释器回显’no.’。
	我们把Prolog的模式匹配工作叫做联合(unification)。当数据库中只包括事实时，以下三个条件是使联合成功的必要条件。
	目标谓词名与数据库中的某个谓词名相同。
	这两个谓词的参数数目相同。
	所有的参数也相同。

	在查询目标中我们还可以使用Prolog的变量。这种变量和其他语言中的不同。叫它逻辑变量更合适一点。变量可以代替目标中的一些参数。
	变量给联合操作带来了新的意义。以前联合操作只有在谓词名和参数都相同时才能成功。但是引入了变量之后，变量可以和任何的条目匹配。
	当联合成功之后，变量的值将和它所匹配的条目的值相同。这叫做变量的绑定(binding)。当带变量的目标成功的和数据库中的事实匹配之后，Prolog将返回变量绑定的值。
	由于变量可能和多个条目匹配，Prolog允许你察看其他的绑定值。在每次Prolog的回答后输入“；”，可以让Prolog继续查询。

	工作原理：当Prolog试图与某一个目标匹配时，例如：location/2，它就在数据库中搜寻所有用location/2定义的子句，当找到一条与目标匹配时，它就为这条子句作上记号。当用户需要更多的答案时，它就从那条作了记号的子句开始向下查询。如果用户输入分号(;)，Prolog就开始寻找其他的答案。首先它必须释放（unbinds）变量X。然后从上一次成功的位置的下一条子句开始继续搜索。这个过程叫做回溯（backtracking）。

	Prolog的目标有四个端口用来控制运行的流程：调用（call）、退出（exit）、重试（redo）以及失败（fail）。一开始使用Call端口进入目标，如果匹配成功就到了exit端口，如果失败就到了fail端口，如果用户输入分号，则又从redo端口进入目标。下图表示了目标和它的四个端口。
	call 开始使用目标搜寻子句。
	exit 目标匹配成功，在成功的子句上作记号，并绑定变量。
	redo 试图重新满足目标，首先释放变量，并从上次的记号开始搜索。
	fail 表示再找不到更多的满足目标的子句了。

	dubug. 进入调试模式，quit. 退出 调试模式
(5)复杂查询
	我们可以把简单的查询连接起来，组成一些较复杂的查询。
	
	简单的查询只有一个目标，而混合查询可以把这些目标连接起来，从而进行较为复杂的查询。上面的连接符号’,’是并且的意思。

	?- location(X, kitchen), edible(X).
	上面的式子用语言来描述就是“寻找满足条件的X，条件是：X在厨房里，并且X能吃。”如果某个变量在询问中多次出现，则此变量在所有出现的位置都必须绑定为相同的值。所以上面的查询只有找到某一个X的值，使得两个目标都成立时，才算查询成功。

	每次查询所使用的变量都是局部的变量，它只在本查询中有意义。

	查询原理
	1.搜索第一个目标，如果成功转到2，如果失败则回答’no’，查询结束。
	2.搜索第二个目标，如果成功转到3，如果失败转到1。
	3.把绑定的变量的值输出。用户输入’;’后转到2。

(6)内部谓词
	Prolog提供的一些内部的函数，我把这些内部函数称为内部谓词。和其他的程序语言一样，Prolog也提供了一些基本的输入输出函数。

	内部谓词是指已经在Prolog中事先定义好的谓词。在内存中的动态数据库中是没有内部谓词的子句的。当解释器遇到了内部谓词的目标，它就直接调用事先编好的程序。

	内部谓词一般所完成的工作都是与逻辑程序无关的，例如输入输出的谓词。所以我们可以把这些谓词叫做非逻辑谓词。

	但是这些谓词也可以作为Prolog的目标，所以它们也必须拥有和逻辑谓词相同的四个端口：Call、Fail、Redo和Exit。

	几个常见的输出谓词:
	1. write/1 此谓词被调用时永远是成功的，并且它可以把它的参数作为字符串输出到屏幕上。当回溯时，它永远是失败，所以回溯是不会把已经写到屏幕上的字符又给删除的。
	2. nl/0 此谓词没有参数，和write一样，从Call端口调用时总是成功的，从Redo端口回溯时总是失败的，它的作用是在屏幕上输出一个回车符。
	3. tab/1 此谓词的参数是一个整数，它的作用是输出n个空格，n为它的参数。其控制流程与上面两个相同。

	还有一个专门引起回溯的内部谓词fail/0，从它的名字不难看出，它的调用永远是失败的。
(7)规则谓词
	规则的实质就是储存起来的查询。其语法为 head :- body.
	head 是谓词的定义部分，与事实一样，也包括谓词名和谓词的参数说明。
	:- 连接符，一般可以读作‘如果’。
	body 一个或多个目标，与查询相同。

	规则的工作原理：首先，Prolog将把目标和规则的子句的头部（head）进行匹配，如果匹配成功，Prolog就把此规则的body部分作为新的目标进行搜索。

	实际上规则就是多层的询问。第一层由原始的目标组成，从下一层开始就是由与第一层的目标相匹配的规则的Body中的子目标组成。
(8)数学计算
	Prolog中也有一些能够进行数学计算的功能，但是数学计算是不好用逻辑的事物来描述的。因此计算一个数学表达式的方法和我们以前所学习的模式匹配有很大的区别。因此，Prolog专门提供了内部谓词is来计算数学表达式。其语法形式如下： X is <数学表达式>
	数学表达式的形式和其他的语言相同。
	Prolog还提供了一些用来比较大小的操作符(> < >= =<)。
	可以在规则中使用这些符号(c_to_F(C, F) :- F is C * 9 / 5 + 32.)
(9)数据管理
	Prolog的程序就是谓词的数据库，我们通常把这些谓词的子句写入Prolog的程序中的。在运行Prolog时，解释器首先把所有的子句调入到内存中。所以这些写在程序中的子句都是固定不变的。同时Prolog还提供了一些内部谓词来动态的控制内存中的子句。
	asserta(X)：将子句X加入到动态数据库中跟子句X谓词相同的第一个子句处，该谓词的回溯是失败，并且不会取消它所完成的工作。例如内存中已有people(a).people(b).事实，运行asserta(people(d))后，内存中的事实将变成people(d).people(a).people(b).
	retract(X)：把子句X从动态数据库中删除。此操作也是永久性的，也就是说回溯的时候不能撤销此操作。
(10)递归
	在Prolog中，当某个谓词的目标中包含了此谓词本身时，Prolog将进行递归调用。
	某一规则被调用时，Prolog使用新的变量为此规则的body部分建立新的查询。由于每次的查询都是独立的，所以某一规则调用其自身与调用其他规则没有任何区别。
	任何语言中的递归定义都包括两个部分：边界条件与递归部分。
	边界条件定义最简单的情况。而递归部分，则首先解决一部分问题，然后再调用其自身来解决剩下的部分，每一次都将进行边界检测，如果剩下的部分已经是边界条件中所定义的情况时，那么递归就圆满成功了。
	规则中所定义的变量都是局部的。这意味着每次调用某一规则时，Prolog都将为此次调用新建一个独立的变量集。因此递归第一层的变量X、T1、T2，与第二层的变量X、T1、T2的变量名虽然相同，但是它们的值却是不同的。
(11)数据结构
	到目前为止，所介绍的事实、查询以及规则都使用的是最简单的数据结构。谓词的参数都是原子或者整数，这些都是Prolog的基本组成元素。
	通过把这些最简单的数据组合起来，可以生成复杂的数据类型，我们称之为结构。结构由结构名和一定数量的参数组成。这与以前所学过的目标和事实是一样的。
	基本格式：functor(arg1, arg2, ...) 结构的参数可以是简单的数据类型或者是另一个结构。
	内部谓词not/1，它的参数是一个目标，如果此目标失败，则它成功；目标成功则它失败。即不能通过当前数据库中的事实和规则推出查询的目标。
(12)模式匹配
	Prolog的最强大的功能之一就是它内建了模式匹配的算法—-联合。
	模式匹配的对象		模式匹配的结果
	1.1变量&任何项目		1.2变量可以与任何项目绑定，其中也包括变量
	2.1原始项目&原始项目	2.2两个原始项目（原子或整数）	只有当它们相同时才能联合
	3.1结构&结构		3.2如果两个结构的每个相应的参数能联合，那么这两个结构可以联合

	Prolog的内部谓词‘=/2’，此谓词当它的两个参数能够联合时成功，反之则失败。
	语法为：=(arg1, arg2) 或者 arg1 = arg2
	此处的等号在Prolog中的意义与其他语言中的不同。它不是数学运算符或者赋值符。
	使用=进行联合操作与Prolog使用目标与子句联合时相同。在回溯时，变量将被释放。
	变量与值的联合，相当于将变量与值进行绑定。X = a. b = X. 分别将变量X与a和b进行绑定。
	变量之间也可以联合。每个变量都对应一个Prolog的内部值。当两个变量之间进行联合时，Prolog就把它们标记为相同的值。
	当两个含变量的结构之间进行联合时，变量所取的值使得这两个结构相同。a(b(c, d)) = a(X). => X = b(c, d)